//
//  AZButton.m
//  DotaAsker
//
//  Created by Zykis on 26/11/2016.
//  Copyright Â© 2016 Zykis. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//
//  This code was generated by Trial version of PaintCode, therefore cannot be used for commercial purposes.
//

#import "AZButton.h"


@implementation AZButton

#pragma mark Cache

static UIColor* _color = nil;
static UIColor* _gradientColor = nil;

static PCGradient* _gradient = nil;

static NSShadow* _shadow = nil;

#pragma mark Initialization

+ (void)initialize
{
    // Colors Initialization
    _color = [UIColor colorWithRed: 0.305 green: 0.498 blue: 0.305 alpha: 1];
    _gradientColor = [UIColor colorWithRed: 0.174 green: 0.163 blue: 0.163 alpha: 1];

    // Gradients Initialization
    CGFloat gradientLocations[] = {0, 0.53, 1};
    _gradient = [PCGradient gradientWithColors: @[AZButton.color, [AZButton.color blendedColorWithFraction: 0.5 ofColor: AZButton.gradientColor], AZButton.gradientColor] locations: gradientLocations];

    // Shadows Initialization
    _shadow = [NSShadow shadowWithColor: UIColor.blackColor offset: CGSizeMake(0, 0) blurRadius: 3];

}

#pragma mark Colors

+ (UIColor*)color { return _color; }
+ (UIColor*)gradientColor { return _gradientColor; }

#pragma mark Gradients

+ (PCGradient*)gradient { return _gradient; }

#pragma mark Shadows

+ (NSShadow*)shadow { return _shadow; }

//// In Trial version of PaintCode, the code generation is limited to 3 canvases.
#pragma mark Drawing Methods

+ (void)drawCanvas1WithIcon: (UIImage*)icon caption: (NSString*)caption rect: (CGRect)rect
{
    [AZButton drawCanvas1WithFrame: CGRectMake(0, 0, 375, 64) resizing: AZButtonResizingBehaviorStretch icon: icon caption: caption rect: rect];
}

+ (void)drawCanvas1WithFrame: (CGRect)targetFrame resizing: (AZButtonResizingBehavior)resizing icon: (UIImage*)icon caption: (NSString*)caption rect: (CGRect)rect
{
    //// General Declarations
    CGContextRef context = UIGraphicsGetCurrentContext();
    
    //// Resize to Target Frame
    CGContextSaveGState(context);
    CGRect resizedFrame = AZButtonResizingBehaviorApply(resizing, CGRectMake(0, 0, 375, 64), targetFrame);
    CGContextTranslateCTM(context, resizedFrame.origin.x, resizedFrame.origin.y);
    CGContextScaleCTM(context, resizedFrame.size.width / 375, resizedFrame.size.height / 64);
    CGFloat resizedShadowScale = MIN(resizedFrame.size.width / 375, resizedFrame.size.height / 64);


    //// Rectangle Drawing
    CGRect rectangleRect = CGRectMake(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
    UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRoundedRect: rectangleRect cornerRadius: 8];
    CGContextSaveGState(context);
    [rectanglePath addClip];
    CGContextDrawLinearGradient(context, AZButton.gradient.CGGradient,
        CGPointMake(CGRectGetMidX(rectangleRect), CGRectGetMinY(rectangleRect)),
        CGPointMake(CGRectGetMidX(rectangleRect), CGRectGetMaxY(rectangleRect)),
        kNilOptions);
    CGContextRestoreGState(context);

    ////// Rectangle Inner Shadow
    CGContextSaveGState(context);
    CGContextClipToRect(context, rectanglePath.bounds);
    CGContextSetShadowWithColor(context, CGSizeZero, 0, NULL);

    CGContextSetAlpha(context, CGColorGetAlpha([AZButton.shadow.shadowColor CGColor]));
    CGContextBeginTransparencyLayer(context, NULL);
    {
        UIColor* opaqueShadow = [AZButton.shadow.shadowColor colorWithAlphaComponent: 1];
        CGContextSetShadowWithColor(context, CGSizeMake(AZButton.shadow.shadowOffset.width * resizedShadowScale, AZButton.shadow.shadowOffset.height * resizedShadowScale), AZButton.shadow.shadowBlurRadius * resizedShadowScale, [opaqueShadow CGColor]);
        CGContextSetBlendMode(context, kCGBlendModeSourceOut);
        CGContextBeginTransparencyLayer(context, NULL);

        [opaqueShadow setFill];
        [rectanglePath fill];

        CGContextEndTransparencyLayer(context);
    }
    CGContextEndTransparencyLayer(context);
    CGContextRestoreGState(context);

    [UIColor.blackColor setStroke];
    rectanglePath.lineWidth = 1;
    [rectanglePath stroke];
    NSMutableParagraphStyle* rectangleStyle = [[NSMutableParagraphStyle alloc] init];
    rectangleStyle.alignment = NSTextAlignmentCenter;
    NSDictionary* rectangleFontAttributes = @{NSFontAttributeName: [UIFont fontWithName: @"Optima-Regular" size: 22], NSForegroundColorAttributeName: UIColor.whiteColor, NSParagraphStyleAttributeName: rectangleStyle};

    CGFloat rectangleTextHeight = [caption boundingRectWithSize: CGSizeMake(rectangleRect.size.width, INFINITY) options: NSStringDrawingUsesLineFragmentOrigin attributes: rectangleFontAttributes context: nil].size.height;
    CGContextSaveGState(context);
    CGContextClipToRect(context, rectangleRect);
    [caption drawInRect: CGRectMake(CGRectGetMinX(rectangleRect), CGRectGetMinY(rectangleRect) + (rectangleRect.size.height - rectangleTextHeight) / 2, rectangleRect.size.width, rectangleTextHeight) withAttributes: rectangleFontAttributes];
    CGContextRestoreGState(context);


    //// IconRectangle Drawing
    UIBezierPath* iconRectanglePath = [UIBezierPath bezierPathWithRect: CGRectMake(8, 8, 48, 48)];
    CGContextSaveGState(context);
    [iconRectanglePath addClip];
    CGContextScaleCTM(context, 1, -1);
    CGContextDrawTiledImage(context, CGRectMake(8, -8, icon.size.width, icon.size.height), icon.CGImage);
    CGContextRestoreGState(context);
    
    CGContextRestoreGState(context);

}

@end



@implementation PCGradient

- (instancetype)initWithColors: (NSArray<UIColor*>*)colors locations: (const CGFloat*)locations
{
    self = [self init];
    if (self != nil)
    {
        NSMutableArray* cgColors = [NSMutableArray array];
        for (UIColor* color in colors)
            [cgColors addObject: (id)color.CGColor];

        _CGGradient = CGGradientCreateWithColors(NULL, (__bridge CFArrayRef)cgColors, locations);
    }
    return self;
}

+ (instancetype)gradientWithColors: (NSArray<UIColor*>*)colors locations: (const CGFloat*)locations
{
    return [[self alloc] initWithColors: colors locations: locations];
}

+ (instancetype)gradientWithStartingColor: (UIColor*)startingColor endingColor: (UIColor*)endingColor
{
    return [[self alloc] initWithColors: @[startingColor, endingColor] locations: NULL];
}

- (void)dealloc
{
    CGGradientRelease(_CGGradient);
}

@end



@implementation NSShadow (PaintCodeAdditions)

- (instancetype)initWithColor: (UIColor*)color offset: (CGSize)offset blurRadius: (CGFloat)blurRadius
{
    self = [self init];
    if (self != nil)
    {
        self.shadowColor = color;
        self.shadowOffset = offset;
        self.shadowBlurRadius = blurRadius;
    }
    return self;
}

+ (instancetype)shadowWithColor: (UIColor*)color offset: (CGSize)offset blurRadius: (CGFloat)blurRadius
{
    return [[self alloc] initWithColor: color offset: offset blurRadius: blurRadius];
}

- (void)set
{
    CGContextSetShadowWithColor(UIGraphicsGetCurrentContext(), self.shadowOffset, self.shadowBlurRadius, [self.shadowColor CGColor]);
}

@end



@implementation UIColor (PaintCodeAdditions)

- (UIColor*)blendedColorWithFraction: (CGFloat)fraction ofColor: (UIColor*)color2
{
    UIColor* color1 = self;

    CGFloat r1 = 0, g1 = 0, b1 = 0, a1 = 0;
    CGFloat r2 = 0, g2 = 0, b2 = 0, a2 = 0;


    [color1 getRed: &r1 green: &g1 blue: &b1 alpha: &a1];
    [color2 getRed: &r2 green: &g2 blue: &b2 alpha: &a2];

    CGFloat r = r1 * (1 - fraction) + r2 * fraction;
    CGFloat g = g1 * (1 - fraction) + g2 * fraction;
    CGFloat b = b1 * (1 - fraction) + b2 * fraction;
    CGFloat a = a1 * (1 - fraction) + a2 * fraction;

    return [UIColor colorWithRed: r green: g blue: b alpha: a];
}

@end



CGRect AZButtonResizingBehaviorApply(AZButtonResizingBehavior behavior, CGRect rect, CGRect target)
{
    if (CGRectEqualToRect(rect, target) || CGRectEqualToRect(target, CGRectZero))
        return rect;

    CGSize scales = CGSizeZero;
    scales.width = ABS(target.size.width / rect.size.width);
    scales.height = ABS(target.size.height / rect.size.height);

    switch (behavior)
    {
        case AZButtonResizingBehaviorAspectFit:
        {
            scales.width = MIN(scales.width, scales.height);
            scales.height = scales.width;
            break;
        }
        case AZButtonResizingBehaviorAspectFill:
        {
            scales.width = MAX(scales.width, scales.height);
            scales.height = scales.width;
            break;
        }
        case AZButtonResizingBehaviorStretch:
            break;
        case AZButtonResizingBehaviorCenter:
        {
            scales.width = 1;
            scales.height = 1;
            break;
        }
    }

    CGRect result = CGRectStandardize(rect);
    result.size.width *= scales.width;
    result.size.height *= scales.height;
    result.origin.x = target.origin.x + (target.size.width - result.size.width) / 2;
    result.origin.y = target.origin.y + (target.size.height - result.size.height) / 2;
    return result;
}
